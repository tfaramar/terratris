{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/index.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;;AAEA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA,uCAAuC;AACvC,wD;AACA,6CAA6C;AAC7C,qBAAqB,WAAW;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,WAAW;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0BAA0B,iBAAiB;AAC3C,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,oCAAoC;AACpC,K;AACA;;AAEA;;AAEA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;;AAEA,mBAAmB,cAAc;AACjC,sBAAsB,cAAc;AACpC;AACA,S;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","console.log('webpack is working!')\n\n//-------------------------------------------Canvas Configuration\nconst canvas = document.getElementById(\"canvas\");\nconst context = canvas.getContext(\"2d\");\ncontext.scale(20, 20); //scale everything x 30\n\ncontext.fillStyle = \"lemonchiffon\";\ncontext.fillRect(0, 0, canvas.clientWidth, canvas.height);\n\n//------------------------------------------Is Paused\nlet isPaused = false;\n\n//------------------------------------------Toggle Pause\nconst togglePause = () => {\n    isPaused = !isPaused;\n    let modal = document.getElementById(\"modal\");\n    modal.classList.toggle('paused');\n    modal.innerHTML = modal.innerHTML === \"\" ? \"Paused\" : \"\";\n}\n\n//-------------------------------------------Draw Piece\nconst drawPiece = (type, offset) => {\n    type.forEach((row, y) => {\n        row.forEach((val, x) => {\n            if (val !== 0) {\n                context.fillStyle = colors[val];\n                context.fillRect(x + offset.x, y + offset.y, 1, 1);\n            }\n        });\n    });\n}\n\nconst draw = () => {\n    context.fillStyle = \"lemonchiffon\"; //first clear canvas\n    context.fillRect(0, 0, canvas.width, canvas.height); \n    drawPiece(newPiece.matrix, newPiece.pos); //then draw piece\n    drawPiece(grid, {x: 0, y: 0}) //draw grid\n}\n\nlet lastTime = 0;\nlet dropCounter = 0;\nlet dropInterval = 1000;\n\n//---------------------------------------------Implement Animation of Piece\nconst update = (time = 0) => {\n    const runTime = time - lastTime;\n    lastTime = time;\n    dropCounter += runTime\n    if ((dropCounter > dropInterval) && !isPaused) {\n        dropPieceByOne();\n    }\n    draw();\n    requestAnimationFrame(update);  \n}\n\n//----------------------------------------------Build Next Piece\n\n\nconst resetPiece = () => {\n    let pieces = [\"T\", \"Z\", \"S\", \"O\", \"L\", \"J\", \"I\"];\n    let rand = Math.floor(pieces.length * Math.random())\n    newPiece.matrix = createPiece(pieces[rand]) \n    //randomly created piece should be pushed onto array of next three pieces, newPiece.matrix should come from the first element in that array\n    newPiece.pos.y = 0;\n    newPiece.pos.x = (Math.floor(grid[0].length / 2)) - (Math.floor(newPiece.matrix.length / 2))  \n    //if full, don't add more, trigger game over. right now this will just clear board. afterward, implement game over\n    if (pieceCollision(grid, newPiece)) {\n        gameOver();\n    }\n}\n\n//---------------------------------------------Game Over\nconst gameOver = () => {\n    isPaused = true;\n    let modal = document.getElementById(\"modal\");\n    modal.classList.add(\"game-over\");\n    modal.innerHTML = \"Try again!\";\n    modal.addEventListener('click', exitGameOver);\n}\n\nconst exitGameOver = () => {\n    let modal = document.getElementById(\"modal\");\n    modal.classList.remove(\"game-over\");\n    modal.innerHTML = \"\";\n    modal.removeEventListener('click', exitGameOver);\n    gameReset();\n}\n\n//---------------------------------------------Game Reset\nconst gameReset = () => {\n    grid.forEach(row => row.fill(0));\n    //set level back to 0\n    isPaused = false;\n}\n\n//numbers correspond to various colors\nconst createPiece = (type) => {\n    if (type === \"T\") {\n\n        return [\n            [0, 0, 0],\n            [1, 1, 1],\n            [0, 1, 0]\n        ];\n    } else if (type === \"Z\") {\n        return [\n            [2, 2, 0],\n            [0, 2, 2],\n            [0, 0, 0]\n        ];\n    } else if (type === \"S\") {\n        return [\n            [0, 3, 3],\n            [3, 3, 0],\n            [0, 0, 0]\n        ];\n    } else if (type === \"L\") {\n        return [\n            [0, 4, 0],\n            [0, 4, 0],\n            [0, 4, 4]\n        ];\n    } else if (type === \"J\") {\n        return [\n            [0, 5, 0],\n            [0, 5, 0],\n            [5, 5, 0]\n        ];\n    } else if (type === \"I\") {\n        return [\n            [0, 6, 0, 0],\n            [0, 6, 0, 0],\n            [0, 6, 0, 0],\n            [0, 6, 0, 0]\n        ];\n    } else if (type === \"O\") {\n        return [\n            [7, 7],\n            [7, 7]\n        ];\n    };\n};\n\nconst pieceMatrix = [\n    [0, 4, 0],\n    [0, 4, 0],\n    [0, 4, 4]\n];\n\nconst newPiece = {\n    pos: {x: 3, y: 0},\n    matrix: pieceMatrix\n}\nwindow.newPiece = newPiece;\n\nconst colors = [\n    null,\n    'palevioletred',\n    'brown',\n    'cornflowerblue',\n    'lightseagreen',\n    'khaki',\n    'darkorange',\n    'darkolivegreen'\n];\n\n//---------------------------------------------Check for Complete Rows\n\nconst gridCheck = () => {\n    outer: for (let y = 0; y < grid.length; y++) {\n        for (let x = 0; x < grid[y].length; x++) {\n            if (grid[y][x] === 0) {\n                continue outer;\n            }\n        }\n\n        const row = grid.splice(y, 1)[0].fill(0) //takes row out at index y and fills it with zeros\n        grid.unshift(row) //add that row to the top of the grid\n    }\n}\n\n//----------------------------------------------Move Piece\n\nconst movePiece = (direction) => {\n    newPiece.pos.x += direction;\n    if (pieceCollision(grid, newPiece)) {\n        newPiece.pos.x -= direction; //if we bump into something, move back\n    }  \n}\n\n//----------------------------------------------Drop Piece by One\n\nconst dropPieceByOne = () => {\n    newPiece.pos.y += 1;\n    if (pieceCollision(grid, newPiece)) {\n       newPiece.pos.y -= 1; //set back one cube on y-axis\n       mergePieceToGrid(grid, newPiece);\n       resetPiece();\n       gridCheck();\n    }\n    dropCounter = 0; //set counter back to zero\n}\n\n//------------------------------------------------Hard Drop Piece\n\nconst hardDrop = () => {\n    while (!pieceCollision(grid, newPiece)) {\n        newPiece.pos.y += 1;\n    }\n    newPiece.pos.y -=1;\n    mergePieceToGrid(grid, newPiece);\n    resetPiece();\n    gridCheck();\n    dropCounter = 0;\n}\n\n//-----------------------------------------------Rotate Piece\n\nconst rotatePiece = (piece) => {\n    let m = piece.matrix\n    let newMatrix = []\n    for (let i = 0; i < m.length; i++) {\n        newMatrix.push([]);\n    };\n\n    for (let i = 0; i < m.length; i++) {\n       for (let j = 0; j < m.length; j++) {\n            newMatrix[j].push(m[i][j]);\n       }; \n    };\n\n    piece.matrix = newMatrix.map((row) => row.reverse());\n\n    if (pieceCollision(grid, piece)) {\n        if (piece.pos.x < 0) {\n            piece.pos.x += 1;\n        } else if (piece.pos.x > (grid[0].length - piece.matrix.length)) {\n            piece.pos.x -= 1;\n        }\n    };\n}\n\n//---------------------------------------------Create Grid\nconst setGrid = (width, height) => {\n    let g = [];\n    while (height > 0) {\n        g.push(new Array(width).fill(0))\n        height -= 1;\n    }\n    return g;\n}\n\nconst grid = setGrid(10, 20);\n\n//---------------------------------------------Merge Piece to Grid\n\nconst mergePieceToGrid = (grid, piece) => {\n    piece.matrix.forEach((row, y) => {\n        row.forEach((val, x) => {\n            if (val !== 0) {\n                grid[y + piece.pos.y][x + piece.pos.x] = val\n            }\n        })\n    })   \n}\n\n//---------------------------------------------Check for Piece Collision\n\nconst pieceCollision = (grid, piece) => {\n    const matrix = piece.matrix;\n    const pos = piece.pos;\n    for (let y = 0; y < matrix.length; y++) {\n        for (let x = 0; x < matrix[y].length; x++) {\n            if ((matrix[y][x] !== 0) && (grid[y + pos.y] && grid[y + pos.y][x + pos.x]) !== 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n//---------------------------------------------Key Events\n\ndocument.addEventListener('keydown', event => {\n    switch(event.keyCode) {\n        case 37:\n            movePiece(-1);\n            break;\n        case 38:\n            rotatePiece(newPiece);\n            break;\n        case 39:\n            movePiece(1);\n            break;\n        case 40:\n            dropPieceByOne();\n            break;\n        case 80:\n            togglePause();\n            break;\n        case 32:\n            hardDrop();\n            break;\n    }\n});\n\n//-----------------------------------------------------Set points\n\n//-----------------------------------------------------Set level\n//when to level up? every 10 lines?\n\n// document.querySelector('audio').addEventListener('play', () => {\n//     console.log('audio playing')\n// })\n\nupdate();\n\n"],"sourceRoot":""}