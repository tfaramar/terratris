{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/index.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;;AAEA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA,gCAAgC;AAChC,wD;AACA;AACA,qBAAqB,WAAW;AAChC;;AAEA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,WAAW;AACrB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,oCAAoC;AACpC,K;AACA;;AAEA;;AAEA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;;AAEA,mBAAmB,cAAc;AACjC,sBAAsB,cAAc;AACpC;AACA,S;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;;;AAIA","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","console.log('webpack is working!')\n\n//-------------------------------------------Canvas Configuration\nconst canvas = document.getElementById(\"canvas\");\nconst context = canvas.getContext(\"2d\");\ncontext.scale(20, 20); //scale everything x 30\n\ncontext.fillStyle = \"white\";\ncontext.fillRect(0, 0, canvas.clientWidth, canvas.height);\n\n//-------------------------------------------Draw Piece\nconst drawPiece = (type, offset) => {\n    type.forEach((row, y) => {\n        row.forEach((val, x) => {\n            if (val !== 0) {\n                context.fillStyle = \"palevioletred\";\n                context.fillRect(x + offset.x, y + offset.y, 1, 1);\n            }\n        });\n    });\n}\n\nconst draw = () => {\n    context.fillStyle = \"white\"; //clear the canvas, consider clearRect instead?\n    context.fillRect(0, 0, canvas.width, canvas.height); \n    drawPiece(newPiece.matrix, newPiece.pos);\n    drawPiece(grid, {x: 0, y: 0})\n}\n\nlet lastTime = 0; //replace with timestamp, broadly supported\nlet dropCounter = 0;\nlet dropInterval = 1000;\n\n//---------------------------------------------Implement Animation of Piece\nconst update = (time = 0) => {\n    const runTime = time - lastTime;\n    lastTime = time;\n    dropCounter += runTime\n    if (dropCounter > dropInterval) {\n      dropPieceByOne();  \n    }\n    draw();\n    requestAnimationFrame(update);\n}\n\nconst pieceMatrix = [\n    [0, 1, 0],\n    [0, 1, 0],\n    [0, 1, 1]\n];\n\nconst newPiece = {\n    pos: {x: 3, y: 0},\n    matrix: pieceMatrix\n}\nwindow.newPiece = newPiece;\n\n//----------------------------------------------Move Piece\n\nconst movePiece = (direction) => {\n    newPiece.pos.x += direction;\n    if (pieceCollision(grid, newPiece)) {\n        newPiece.pos.x -= direction; //if we bump into something, move back\n    }  \n}\n\n//----------------------------------------------Drop Piece by One\n\nconst dropPieceByOne = () => {\n    newPiece.pos.y += 1;\n    if (pieceCollision(grid, newPiece)) {\n       newPiece.pos.y -= 1; //set back one cube on y-axis\n       mergePieceToGrid(grid, newPiece);\n       newPiece.pos.y = 0;\n    }\n    dropCounter = 0 //set counter back to zero\n}\n\n//-----------------------------------------------Rotate Piece\n\nconst rotatePiece = (piece) => {\n    let m = piece.matrix\n    let newMatrix = []\n    for (let i = 0; i < m.length; i++) {\n        newMatrix.push([]);\n    };\n\n    for (let i = 0; i < m.length; i++) {\n       for (let j = 0; j < m.length; j++) {\n            newMatrix[j].push(m[i][j]);\n       }; \n    };\n\n    piece.matrix = newMatrix.map((row) => row.reverse());\n\n    if (pieceCollision(grid, piece)) {\n        if (piece.pos.x < 0) {\n            piece.pos.x += 1;\n        } else if (piece.pos.x > (grid[0].length - piece.matrix.length)) {\n            piece.pos.x -= 1;\n        }\n    };\n}\n\n//---------------------------------------------Create Grid\nconst setGrid = (width, height) => {\n    let g = [];\n    while (height > 0) {\n        g.push(new Array(width).fill(0))\n        height -= 1;\n    }\n    return g;\n}\n\nconst grid = setGrid(10, 20);\n\nconst mergePieceToGrid = (grid, piece) => {\n    piece.matrix.forEach((row, y) => {\n        row.forEach((val, x) => {\n            if (val !== 0) {\n                grid[y + piece.pos.y][x + piece.pos.x] = val\n                //console.log(grid);\n            }\n        })\n    })   \n}\n\nconst pieceCollision = (grid, piece) => {\n    const matrix = piece.matrix;\n    const pos = piece.pos;\n    for (let y = 0; y < matrix.length; y++) {\n        for (let x = 0; x < matrix[y].length; x++) {\n            if ((matrix[y][x] !== 0) && (grid[y + pos.y] && grid[y + pos.y][x + pos.x]) !== 0) {\n                //console.log('collision!', grid);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\ndocument.addEventListener('keydown', event => {\n    switch(event.keyCode) {\n        case 37:\n            movePiece(-1);\n            console.log('moved left');\n            break;\n        case 38:\n            rotatePiece(newPiece);\n            console.log('rotate piece');\n            break;\n        case 39:\n            movePiece(1);\n            console.log('moved right');\n            break;\n        case 40:\n            dropPieceByOne()\n            console.log('down one');\n            break;\n        case 80:\n            console.log('paused');\n            break;\n        case 32:\n            console.log('drop piece');\n            break;\n    }\n});\n\n//-----------------------------------------------------Set points\n\n//-----------------------------------------------------Set level\n//when to level up? every 10 lines?\n\n\n\nupdate();\n\n"],"sourceRoot":""}